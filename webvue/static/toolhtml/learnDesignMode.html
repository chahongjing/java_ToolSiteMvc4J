<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <title>学习设计模式</title>
    <link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
    <link rel='stylesheet' type='text/css' href='../css/common.css'>
</head>

<body class='elearn'>
    <h2>主要分三类</h2>
    <ul class="list">
        <li>创建型模式（5种）：工厂方法模式，抽象工厂模式，单例模式，建造者模式，原型模式。</li>
        <li>结构型模式（7种）：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式。</li>
        <li>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
    </ul>
    <hr>
    <h2>六大原则</h2>
    <ul class="list">
        <li>单一职责原则（Composite Reuse Principle）：该原则是针对类来说的，即一个类应该只负责一项职责。</li>
        <li>开闭原则（Open Close Principle）：对扩展开放，对修改关闭。</li>
        <li>里氏代换原则（Liskov Substitution Principle）：只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li>
        <li>依赖倒转原则（Dependence Inversion Principle）：这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。</li>
        <li>接口隔离原则（Interface Segregation Principle）：一个类对另一个类的依赖应该建立在最小的接口上</li>
        <li>迪米特法则（最少知道原则）（Demeter Principle）：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
    </ul>
    <hr>
    <h2>23种设计模式</h2>
    <ul class="list">
        <li>1。工厂模式（Factory Method），一个工厂返回不同实例
            <ul class="list">
                <li>StaticFactory.getA();</li>
                <li>StaticFactory.getB();</li>
            </ul>
        </li>
        <li>2。抽象工厂模式（Abstract Factory），多个工厂实现接口中的get方法
            <ul class="list">
                <li>new FactoryForA().get()</li>
                <li>new FactoryForB().get()</li>
            </ul>
        </li>
        <li>3。单例模式（Singleton）
            <ul class="list">
                <li>静态构造函数或静态代码块初始化实例</li>
            </ul>
        </li>
        <li>4。建造者模式（Builder），属性较多，多个构造函数重载也无法满足条件
            <ul class="list">
                <li>new Student.StudentBuilder().setAge(13).setName("LiHua").build();</li>
            </ul>
        </li>
        <li>5。原型模式（Protype）
            <ul class="list">
                <li>使用clone方法复制</li>
            </ul>
        </li>
        <li>6。适配器模式（Adapter）
            <ul class="list">
                <li>适配器模式的作用就是在原来的类上提供新功能。class  adapter extends oldClass  implements newFunc{}</li>
            </ul>
        </li>
        <li>7。装饰模式（Decorator）
            <ul class="list">
                <li>子类实现父类方法，在方法中调用子类同名方法前后调用其它接口</li>
                <li>差异：装饰器与适配器都有一个别名叫做 包装模式(Wrapper)，它们看似都是起到包装一个类或对象的作用，但是使用它们的目的很不一一样。适配器模式的意义是要将一个接口转变成另一个接口，它的目的是通过改变接口来达到重复使用的目的。 而装饰器模式不是要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有对象的功能，或者改变原有对象的处理方式而提升性能</li>
            </ul>
        </li>
        <li>8。代理模式（Proxy）
        </li>
        <li>9。外观模式（Facade）：设计一个外观类，这样就可以实现统一的接口
            <ul class="list">
                <li>
                    <pre><code>
public class Facade {
    private subSystem1 subSystem1 = new subSystem1();
    private subSystem2 subSystem2 = new subSystem2();
    private subSystem3 subSystem3 = new subSystem3();
    
    public void startSystem(){
        subSystem1.start();
        subSystem2.start();
        subSystem3.start();
    }
    
    public void stopSystem(){
        subSystem1.stop();
        subSystem2.stop();
        subSystem3.stop();
    }
}
                    </code></pre>
                </li>
            </ul>
        </li>
        <li>10。桥接模式（Bridge）
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>11。组合模式（Composite）
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>12。享元模式（Flyweight）
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>13。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>14。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>15。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>16。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>17。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>18。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>19。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>20。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>21。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>22。
            <ul class="list">
                <li></li>
            </ul>
        </li>
        <li>23。
            <ul class="list">
                <li></li>
            </ul>
        </li>
    </ul>
</body>

</html>
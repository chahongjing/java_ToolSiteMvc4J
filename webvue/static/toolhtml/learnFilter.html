<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<title>学习filter</title>
	<link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
	<link rel='stylesheet' type='text/css' href='../css/common.css'>
	<script src='../js/jquery-3.3.1.min.js'></script>
</head>

<body class='elearn'>
	<h3>对请求前后进行特殊处理</h3>
	<p>
		<ul class='list'>
			<li>三个接口Filter, FilterConfig, FilterChain</li>
			<li>在web.xml中配置并映射filter</li>
			<li>实现三个方法
				<ul class='list'>
					<li>public void init(FilterConfig filterConfig),filter加载当前应用时执行一次，且只被执行一次, 是单例的</li>
					<li>public void doChain(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
					</li>
					<li>public void destory(),filter销毁前执行，且只执行一次</li>
				</ul>
			</li>
			<li>多个filter拦截顺序（不是创建顺序）是和web.xml中配置的&lt;filter-mapping&gt;节点的顺序一致</li>
			<li>在filter-mapping中可配置&lt;dispatcher&gt;节点中配置request或foward或include或error，如果想配置多个，则要多个dispatcher节点</li>
		</ul>
	</p>
	<hr>
	<h3>HttpFilter</h3>
	<p>
		<ul class='list'>
			<li>类似HttpServlet</li>
			<li>常用方法
				<ul class='list'>
					<li>使浏览器不缓存页面<br>
						<ul class='list'>
							<li>response.setDataHeader("Expires", -1);</li>
							<li>response.setHeader("Cache-Control", "no-cache");</li>
							<li>response.setHeader("Pragma", "no-cache")</li>
						</ul>
					</li>
				</ul>
				<ul class='list'>
					<li>字符编码过滤器<br>
						1. request.setCharacterEncoding(StandardCharsets.UTF_8.name());<br>
						2. 要设置的编码可以从filterconfig中获取servletcontext，然后再获取配置中指定的编码
					</li>
				</ul>
				<ul class='list'>
					<li>验证用户登录<br>
						1. urls:放行url,redirectUrl:登录页面,servletPath:request.getServletPath()<br>
						2. if(urls.contains(servletPath)) {filterChain.doFilter(request, response);return;}<br>
						3. if(session.getAttribute("loginSessionKey") == null)
						{response.setRedirect(request.getContextPath() + redirectUrl);}<br>
						4. 说明已登录, 则直接执行filterChain.doFilter(request, response);
					</li>
				</ul>
			</li>
		</ul>
	</p>
	<hr>
	<h2>过滤器(Filter)和拦截器(Interceptor)</h2>
	<ul class='list'>
		<li>Filter可以认为是Servlet的一种“加强版”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。Filter也可以对用户请求生成响应，这一点与Servlet相同，但实际上很少会使用Filter向用户请求生成响应。使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。
			<ul class="list">
				<li>void init(FilterConfig config):用于完成Filter的初始化。</li>
				<li>void destory():用于Filter销毁前，完成某些资源的回收。</li>
				<li>void doFilter(ServletRequest request,ServletResponse response,FilterChain
					chain):实现过滤功能，该方法就是对每个请求及响应增加的额外处理。该方法可以实现对用户请求进行预处理(ServletRequest
					request)，也可实现对服务器响应进行后处理(ServletResponse
					response)—它们的分界线为是否调用了chain.doFilter(),执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。</li>
			</ul>
		</li>
		<li>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor
			非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor
			接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter
			；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。
			<ul class="list">
				<li>preHandle (HttpServletRequest request, HttpServletResponse response, Object handle)
					方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor
					的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle
					方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean类型的，当它返回为false
					时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle
					方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。</li>
				<li>postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView
					modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle
					方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet
					进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle
					是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行，这和Struts2 里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor
					的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor
					中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</li>
				<li>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)
					方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet
					渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。</li>
			</ul>
		</li>
	</ul>
	<table class="table table-hover">
		<thead>
			<tr>
				<th>Filter</th>
				<th>Interceptor</th>
				<th>Summary</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Filter 接口定义在 javax.servlet 包中</td>
				<td>接口 HandlerInterceptor 定义在org.springframework.web.servlet 包中</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td>Filter 定义在 web.xml 中</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
			</tr>
			<tr>
				<td>Filter在只在 Servlet 前后起作用。Filters 通常将 请求和响应（request/response） 当做黑盒子，Filter 通常不考虑servlet 的实现。</td>
				<td>拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。允许用户介入（hook into）请求的生命周期，在请求过程中获取信息，Interceptor 通常和请求更加耦合。</td>
				<td>在Spring构架的程序中，要优先使用拦截器。几乎所有 Filter 能够做的事情， interceptor 都能够轻松的实现
				</td>
			</tr>
			<tr>
				<td>Filter 是 Servlet 规范规定的。</td>
				<td>而拦截器既可以用于Web程序，也可以用于Application、Swing程序中。</td>
				<td>使用范围不同</td>
			</tr>
			<tr>
				<td>Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的。</td>
				<td>而拦截器是在 Spring容器内的，是Spring框架支持的。</td>
				<td>规范不同</td>
			</tr>
			<tr>
				<td>Filter 不能够使用 Spring 容器资源</td>
				<td>拦截器是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如 Service对象、数据源、事务管理等，通过IoC注入到拦截器即可
				</td>
				<td>Spring 中使用 interceptor 更容易</td>
			</tr>
			<tr>
				<td>Filter 是被 Server(like Tomcat) 调用</td>
				<td>Interceptor 是被 Spring 调用</td>
				<td>因此 Filter 总是优先于 Interceptor 执行</td>
			</tr>
		</tbody>
	</table>
	<script>
	    $(function() {
			$('td').each(function() {
				$(this).attr('title', $(this).text());
			});
		});
	</script>
</body>

</html>
<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<title>学习js</title>
	<link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
	<link rel='stylesheet' type='text/css' href='../css/common.css'>
</head>
<body class='elearn'>
	<h2>
	</h2>
	<p>
		<button onclick='blobDownload()'>下载</button>
		<button id='lnkTestPromise'>测试promise</button>
		<input type='file' name='myfile' multiple />
		<button id='lnkTestUpload'>测试上传</button>
		<br><br>
		<a href='https://developer.mozilla.org/zh-CN/docs/Web' target='_blank'>web官方链接</a>
	</p>
	<hr>
	<h2>Array</h2>
	<p>
		<ul class="list">
			<li>Array.isArray(myArr)</li>
			<li>Array.from(mySet)：Set转Array</li>
			<li>myArr.every(function(item) { return item.abc > 1; })</li>
			<li>myArr.filter(function(item) { return item.abc > 1; })</li>
			<li>找到第一个适合的元素。myArr.find(function(item) { return item.abc > 1; })</li>
			<li>找到第一个适合的元素的索引。myArr.indexOf(element, 3), myArr.findIndex(function(item) { return item.abc > 1; })</li>
			<li>是否符合条件。myArr.includes(element), myArr.some(function(item) { return item.abc > 1; });</li>
			<li>myArr.keys()</li>
			<li>myArr.reduce(callback[, initialValue])</li>
			<li>reverse, shift, sort, unshift, splice, myArr.slice([begin[, end]])</li>
			<li>Array.prototype.push.apply(arr1, arr2);</li>
			<li>Math.max.apply(null, [2,1,3]);</li>
		</ul>
	</p>
	<hr>
	<h2>Set</h2>
	<p>
		<ul class="list">
			<li>new Set(myArray); Array转Set</li>
			<li>Set.add(el)</li>
			<li>Set.size</li>
			<li>Set.delete(el)</li>
			<li>Set.clear()</li>
			<li>Set.entries()</li>
			<li>Set.forEach</li>
			<li>Set.has(el)</li>
			<li>Set.keys()</li>
			<li>Set.values()</li>
		</ul>
	</p>
	<hr>
	<h2>amd cmd commonjs</h2>
	<p>
		<ul class="list">
			<li>服务端：commonjs，框架有node.js</li>
			<li>浏览器：amd, cmd; amd框架有requirejs, cmd框架有seajs</li>
			<li>commonjs, var math = require('math'); math.add(2, 3);只有math.js加载完成后才会执行后一句代码，同步的，服务端文件都在本地，
				加载时间为读取文件时间，但浏览器端却要从服务器下载文件，导致页面卡住，因此就有了amd异步加载模块</li>
			<li><pre><code>AMD
	require(['math'], function (math) {
		math.add(2, 3);
	});

	//AMD
	define(['./a','./b'],function(a,b){
		a.doSomething()
		b.dosomething()
	})
	//CMD
	define(function(require,exports,module){
		var a=require('./a')
		a.doSomethimg()
		var b=require('./b')
		b.doSomething()
	})</code></pre>
	</li>
	<li>AMD和CMD最大的区别是对依赖模块的执行时机处理不同,注意不是加载的时机或者方式不同,
		加载模块都是异步的,只不过AMD依赖前置,js可以方便知道依赖模块是谁,立即加载,而CMD就近依赖,需要使用把模块变为字符串解析一遍才知道依赖了那些模块,这也是很多人诟病CMD的一点,牺牲性能来带来开发的便利性,实际上解析模块用的时间短到可以忽略
	</li>
</ul>
</p>
<hr>
<h2>滚动条</h2>
<p>
    <h3>js</h3>
	<ul class="list">
		<li>offsetTop（offsetLeft）：获取相对于父级的左边距(往上找position:relative的元素，如果没有则为浏览器窗口)。</li>
		<li>offsetHeight（offsetWidth）：元素可视窗口大小，offsetheight = height + padding + 横向滚动轴高度 + <b>border</b></li>
		<li>clientHeight（clientWidth）：元素可视窗口大小，offsetheight = height + padding + 横向滚动轴高度</li>
        <li>scrollHeight（scrollWidth）：元素总高度，包括超出隐藏部分</li>
        <li>scrollTop：获取滚动条滚动的高度</li>
		<li>用于获取鼠标坐标（相对于页面的坐标） clientX 、clientY</li>
	</ul>
    <h3>jquery</h3>
	<ul class="list">
		<li>$el.height(),元素的可视高度</li>
		<li>$el.scrollTop(), 元素滚动的高度</li>
	</ul>
    <h3>其它</h3>
	<ul class="list">
		<li>屏幕宽度：window.screen.width</li>
		<li>移动到(0, 0)点：window.moveTo(0, 0)</li>
		<li>设置窗口大小：window.resizeTo(intX, intY)</li>
	</ul>
</p>
<hr>
<h2>js判断类型</h2>
<p>
    <h3>typeof</h3>
	<ul class="list">
		<li> typeof   2      输出   number</li>
		<li> typeof   null   输出   object</li>
		<li>typeof   {}    输出   object</li>
        <li>typeof    []    输出   object</li>
        <li>typeof   (function(){})   输出  function</li>
		<li>typeof    undefined         输出  undefined</li>
		<li>typeof   '222'                 输出    string</li>
		<li> typeof  true                   输出     boolean</li>
	</ul>
	<h3>instanceof</h3>
	<ul class='list'>
	  <li>[] instanceof Array; // true</li>
	  <li>{} instanceof Object;// true</li>
      <li>new Date() instanceof Date;</li>
	</ul>
	<h3>判断类型</h3>
	<ul class='list'>
      <li>Object.prototype.toString.call(data) == '[object Object]'</li>
      <li>Object.prototype.toString.call(arg) === '[object Array]'</li>
	</ul>
</p>
<hr>
<script src='./../js/jquery-3.3.1.min.js'></script>
<script src='./../js/Utility.js'></script>
<script>
// blob下载
function blobDownload() {
	var url = Utility.getServerUrl() + "/learn/download";
	Utility.jsBlobDownload(url);
}

$('#lnkTestPromise').one('click', function () {
	console.log('click');
	var p1 = $.ajax({
		url: Utility.getServerUrl() + '/learn/testP1'
	}).then(function (data) {
		console.log('testP1');

		return 'p1';
	});

	var p2 = $.ajax({
		url: Utility.getServerUrl() + '/learn/testP2'
	}).then(function (data) {
		console.log('testP2');

		return 'p2';
	});

	Promise.all([p1, p2]).then(function (result) {
		console.log(result);
	});
});

$('#lnkTestUpload').click(function() {
    // var $form = $('#formId');
    // var formData = new FormData($form[0]);
	var formData = new FormData();
    var files = $('input[name=myfile]')[0].files;
    formData.append('userCode', 'zjy');
    formData.append('userName', '曾军毅');
    formData.append('birthday', new Date());
    if(files && files.length > 0) {
        for (var i = 0; i < files.length; i++) {
            formData.append("myfile", files[i]);
        }
    }

    $.ajax({
        url: Utility.getServerUrl() + '/learn/testPostWithFile',
        type: 'post',
        processData: false,
        contentType: false,
        data: formData,
        success: function (resp) {
        	console.log(resp);
        },
        error:function(xhr, a, b) {
            console.log(xhr);
        }
    });
});
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'> 
	<title>学习js</title>
	<link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
	<link rel='stylesheet' type='text/css' href='../css/common.css'>
</head> 
<body class='elearn'>
	<h2>Array</h2>
	<p>
		<ul class="list">
			<li>Array.isArray(myArr)</li>
			<li>myArr.every(function(item) { return item.abc > 1; })</li>
			<li>myArr.filter(function(item) { return item.abc > 1; })</li>
			<li>找到第一个适合的元素。myArr.find(function(item) { return item.abc > 1; })</li>
			<li>找到第一个适合的元素的索引。myArr.indexOf(element, 3), myArr.findIndex(function(item) { return item.abc > 1; })</li>
			<li>是否符合条件。myArr.includes(element), myArr.some(function(item) { return item.abc > 1; });</li>
			<li>myArr.keys()</li>
			<li>myArr.reduce(callback[, initialValue])</li>
			<li>reverse, shift, sort, unshift, splice, myArr.slice([begin[, end]])</li>
			<li>Array.prototype.push.apply(arr1, arr2);</li>
			<li>Math.max.apply(null, [2,1,3]);</li>
		</ul>
	</p>
	<hr>
	<h2>amd cmd commonjs</h2>
	<p>
		<ul class="list">
			<li>服务端：commonjs，框架有node.js</li>
			<li>浏览器：amd, cmd; amd框架有requirejs, cmd框架有seajs</li>
			<li>commonjs, var math = require('math'); math.add(2, 3);只有math.js加载完成后才会执行后一句代码，同步的，服务端文件都在本地，
				加载时间为读取文件时间，但浏览器端却要从服务器下载文件，导致页面卡住，因此就有了amd异步加载模块</li>
				<li><pre><code>AMD
					require(['math'], function (math) {
					math.add(2, 3);
				});

				//AMD
				define(['./a','./b'],function(a,b){
				a.doSomething()
				b.dosomething()
			})
			//CMD
			define(function(require,exports,module){
			var a=require('./a')
			a.doSomethimg()
			var b=require('./b')
			b.doSomething()
		})</code></pre>
	</li>
	<li>AMD和CMD最大的区别是对依赖模块的执行时机处理不同,注意不是加载的时机或者方式不同,
		加载模块都是异步的,只不过AMD依赖前置,js可以方便知道依赖模块是谁,立即加载,而CMD就近依赖,需要使用把模块变为字符串解析一遍才知道依赖了那些模块,这也是很多人诟病CMD的一点,牺牲性能来带来开发的便利性,实际上解析模块用的时间短到可以忽略
	</li>
</ul>
</p>

<script>
// blob下载
function blobDownload() {
	var url = ctx + "/learn/download";
	var xhr;
	if (window.XMLHttpRequest) {
		xhr = new XMLHttpRequest();
	} else if (window.ActiveXObject) {
		xhr = new ActiveXObject("Microsoft.XMLHTTP");
	}
	xhr.open('GET', url, true);
	xhr.responseType = "blob";
	xhr.onload = function () {
		if (this.status == 200) {
			Utility.blobDownload([this.response], this.getResponseHeader('Content-Disposition'), this.getResponseHeader('Content-Type'));
		} else {
			Utility.readBlobAsText(this.response, function(data) {
				alert(data);
			});
		}
	}
	xhr.send();
}

$('#lnkTestPromise').one('click', function () {
	console.log('click');
	var p1 = $.ajax({
		url: ctx + '/test/testP1'
	}).then(function (data) {
		console.log('testP1');

		return 'p1';
	});

	var p2 = $.ajax({
		url: ctx + '/test/testP2'
	}).then(function (data) {
		console.log('testP2');

		return 'p2';
	});

	Promise.all([p1, p2]).then(function (result) {
		console.log(result);
	});
});
</script>
</body> 
</html>
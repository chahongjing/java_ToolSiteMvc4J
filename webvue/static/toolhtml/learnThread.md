# 多线程
- 继承Thread类, 它继承Runnable接口
- 实现Runnable接口，实现run方法，没有返回值不能抛出受检查的异常
- 实现Callable接口(1.5)，实现call方法，他有返回值，可以抛出受检查的异常
- 线程池
  - Executor，Executors，ExecutorService，CompletionService，Future，Callable
  - FixedThreadPool:创建固定数目线程的线程池。不是一次创建指定数量线程，而是逐步创建，直到到达指定数量，如果其中有线程异常而中止，则会补充一个线程，但不会超过指定数量。
  - CachedThreadPool:创建一个可缓存的线程池,如果现有线程没有可用的，则创建一个新线 程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
  - SingleThreadExecutor:创建一个单线程化的Executor。
  - ScheduledThreadPool:创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。
  - https://www.cnblogs.com/fengsehng/p/6048609.html
- Future接口；可对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果
- FutureTask实现RunnableFuture，RunnableFuture继承Runnable, Future
- jvm只有在所有非守护线程都结束时才会结束，如果无法正确关闭excutor那么jvm将无法结束。ExecutorService中有shutdown用来平滑的关闭过程，正在进行的任务和未进行的任务都可以正常结束，但不能再提交新的任务。如果相立即结束所有任务，包括正在执行的，可以用shutdownNow方法。jvm结束时会调用结束勾子，RunTime.addShutdownHook(Thread)
# 锁类型
- 可重入锁：当前线程如果获取到对象锁，当再次进入到此对象的同步代码时（如重复，递归等）可以直接执行而不用等待。
- 自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
- 公平锁/非公平锁；是否按申请顺序来获取锁
- 独享锁/共享锁：是否被多个线程共有
- 互斥锁：对共享资源加锁后，直到解锁后才可以再次访问
- 读写锁：即是互斥锁也是共享锁,read是共享，wirte是互斥；三种状态:读加锁状态、写加锁状态和不加锁状态
- 悲观锁：假设最坏的情况，每次使用都认为别人会修改，所以每次使用时都会上锁，显示声明的锁都是悲观锁
- 乐观锁：假设最好的情况，每次使用都认为别人不会修改，所以每次使用不上锁，但在更新时判断(C)下在此期间别人有没有去更新(S), CAS。无锁编程才是乐观锁，如concurrent包下的容器。
- 分段锁：其实不是锁，只是一种设计，如ConcurrentHashMap
- 闭锁：当闭锁达到某种状态前没有任何线程可以通过，当达到这种状态后所有线程都可以通过，并且状态不会再改变，他是一次性对象，不能被重置，如CountDownLatch
- 栅栏：CyclicBarrier
- 死锁：线程为获取临界资源而相互等待，都处于阻塞状态
- 活锁：任务没被阻塞，但由于条件未满足，一直重复尝试，且一直失败。如从一个队列中拿数据执行，如果执行失败，再把数据放加队列中。如果此任务一直失败，则会一直从队列中拿数据，执行，返回循环操作。
# 常见的锁
- ReentrantLock可重入锁，悲观锁
- ReadWriteLock读写锁。对象暴露两个lock对象，一个用于读，一个用于写，允许多读，一个写，但读和写不能同时进行
- StampedLock，是1.8新增的锁，对ReadWriteLock的升级版本，解决读和写悲观锁的并发问题
- Semaphore：可以控同时访问的线程个数，如一个资源可以同时最多让5个线程访问
- CountDownLatch:等其它几个操作执行完成后再执行当前操作（多个后执行一个），一般用于等待事件。不能被重置。
- CyclicBarrier：让一组操作等待某个状态后再全部同时执行（等待一个后执行多个），一般用于等待其它线程。可以被重置供下次使用。
- synchronized悲观锁，重量级，不仅可以修改变量，还可修饰方法。synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。 使用monitorenter和monitorout变量，这个变量在对象头上，对方法则是使用标识ACC_SYNCHRONIZED
- java.util.concurrent包全完建立在CAS之上,即乐观锁
- AtomicInteger
- volatile：他不是锁。线程执行时，先把变量从主内存读取到线程自己的本地内存空间，然后再对该变量进行操作，对该变量操作完后，在某个时间再把变量刷新回主内存。JVM将内存组织为主内存和工作内存两个部分。主内存主要包括本地方法区和堆，每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程私有的栈和对主存部分变量拷贝的寄存器(包括程序计数器PC和cup工作的高速缓存区)。它是保证每次读取变量都从主内存中读取。volatile 修饰的变量会禁止指令重排序。volatile轻量级，只能修饰变量。volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。
- 线程安全性包括两个方面，①可见性。②原子性。仅仅使用volatile并不能保证线程安全性。而synchronized则可实现线程的安全性。
# 降低锁的竞争程序有三种方式
- 减少锁的持有时间
- 降低锁的请求频率
- 使用带有协调机制的独占锁，这些机制允许更高的并发性。
# 锁状态
- 无锁状态
- 偏向锁状态：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
- 轻量级锁状态：轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
- 重量级锁状态：重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
# 其它
- Unsafe: Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。其是CAS的核心类
- CAS: Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。有ABA漏洞问题,使用AtomicStampedReference解决
- 内置锁：Java语言中，提供了2种锁
  - 语言特性提供的内置锁:每一个对象都可以是一个锁,使用方式就是使用 synchronized 关键字，synchronized 方法或者 synchronized 代码块。
  - java.util.concurrent.locks 包中的锁
- Thread.holdsLock(Object obj)来检查一个对象是否被锁定
# CountDownLatch和CyclicBarrier
| CountDownLatch | CyclicBarrier |
| ------ | ------ |
| 减计数方式 | 	加计数方式 |
| 计算为0时释放所有等待的线程 | 计数达到指定值时释放所有等待线程 |
| 计数为0时，无法重置 | 计数达到指定值时，计数置为0重新开始 |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
| 不可重复利用 | 可重复利用 |
# sleep()方法和wait()方法简单对比
- 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁 。
- 两者都可以暂停线程的执行。
- Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。
# CAP理论
- Consistency（一致性）
- Availability（可用性）
- Partition tolerance（分区容错性）

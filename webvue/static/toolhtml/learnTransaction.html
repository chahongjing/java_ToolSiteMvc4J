<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<title>学习事务</title>
	<link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
	<link rel='stylesheet' type='text/css' href='../css/common.css'>
</head>

<body class='elearn'>
	<h2>事务配置方式</h2>
	<ul>
		<li>编程式事务管理：需要在业务层代码手工编写事务代码，灵活但不方便。使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</li>
		<li>声明式事务管理：无需污染业务代码，建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</li>
		<li>显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</li>
		<li>声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。</li>
	</ul>
	<hr>
	<h2>事务配置方式一、注解</h2>
	<ul>
		<li>添加transactionManager&nbsp;&nbsp;bean</li>
		<li>添加tx:annotation-driven，指定transaction-manager</li>
		<li>然后就可以使用Transactional注解标记事务</li>
	</ul>
	<hr>
	<h2>事务配置方式二、xml配置</h2>
	<ul>
		<li>添加transactionManager的bean</li>
		<li>配置事务属性tx:advice</li>
	</ul>
	<hr>
	<h2>@Transactional</h2>
	<ul class='list'>
		<li>事务注解方式
			<ul class='list'>
				<li>标注在类前：标示类中所有方法都进行事务处理</li>
				<li>标注在接口、实现类的方法前：标示方法进行事务处理</li>
			</ul>
		</li>
		<li>属性
			<ul class='list'>
				<li>value：指定事务容器，一般为transactionManager</li>
				<li>propagation：enum: Propagation</li>
				<li>isolation： enum: Isolation</li>
				<li>readOnly：读写或只读事务，默认读写,若为只读，可以提高性能</li>
				<li>timeout：int (in seconds granularity)</li>
				<li>rollbackFor：Class对象数组，必须继承自Throwable </li>
				<li>rollbackForClassName：类名数组，必须继承自Throwable 导</li>
				<li>noRollbackFor：Class对象数组，必须继承自Throwable </li>
				<li>noRollbackForClassName：类名数组，必须继承自Throwable 导</li>
			</ul>
		</li>
		<li>事务传播propagation
			<ul class='list'>
				<li>Propagation.REQUIRED：如果有事务， 那么加入事务， 没有的话新建一个(默认情况下)，默认值</li>
				<li>Propagation.NOT_SUPPORTED：容器不为这个方法开启事务，如果有事务，则事务挂起</li>
				<li>Propagation.REQUIRES_NEW：不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务</li>
				<li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常</li>
				<li>Propagation.NEVER：必须在一个没有的事务中执行，否则抛出异常(与Propagation.MANDATORY相反)</li>
				<li>Propagation.SUPPORTS：如果其他bean调用这个方法，在其他bean中声明事务，那就用事务。如果其他bean没有声明事务，那就不用事务</li>
				<li>Propagation.NESTED，如果有事务，则在这个事务的嵌套事务中运行，否则开启一个新事务</li>
			</ul>
		</li>
		<li>事务隔离级别isolation
			<ul class='list'>
				<li>Isolation.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是ISOLATION_READ_COMMITTED</li>
				<li>Isolation.READ_UNCOMMITTED：会产生脏读，不可重复读和幻像读。</li>
				<li>Isolation.READ_COMMITTED：不会出现脏读，但是可能会出现不可重复读和幻读。保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</li>
				<li>Isolation.REPEATABLE_READ：不会出现脏读，不可重复读。可能出现幻读。SQLSERVER默认。</li>
				<li>Isolation.SERIALIZABLE：串行化，读的时候加表锁，并发量最低代价最高，但会避免脏读，不可重复读外，幻读</li>
			</ul>
		</li>
		<li>事务隔离级别各种问题
			<ul class="list">
				<li>脏读 : T1事务想要读取数据A（值为1）,但在读之前事务T2对A数据进行了修改（值改为2）但未提交，此时T1事务读取出来的数据是2，也就是读取了其它事务未提交的数据。</li>
				<li>不可重复读 : T1事务读了A数据（值为1），之后事务T2对A进行了修改（改为2），然后事务T1继续读取A数据，取的值为2，即同一事务中两次查询结果不一致。</li>
				<li>幻读 : 一个事务读到另一个事务已提交的insert数据</li>
				<li>不可重复读重点在于update和delete，它只能锁住数据库已有的数据，而幻读的重点在于insert，对于新增的数据却没有锁。因此可重复读是数据库已有的数据，幻读会多数据。</li>
			</ul>
		</li>
		<li>使用
			<ul class="list">
				<li>只能添加在public方法上。可以添加在private,protected方法上，但会失效</li>
				<li>只有抛出RuntimeException才会回滚，如果不是则不会回滚</li>
			</ul>
		</li>
	</ul>
	<hr>
</body>

</html>
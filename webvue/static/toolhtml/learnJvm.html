<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'> 
	<title>学习jvm</title>
	<link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
	<link rel='stylesheet' type='text/css' href='../css/common.css'>
</head> 
<body class='elearn'>
	<h2>java虚拟机</h2>
	<p>
		<ul class="list">
			<li>一般有三个概念，一：抽象规范；二:一个具体的实现；三：一个运行中的虚拟机实例
			</li>
			<li>jvm内部有两种线程：守护线程和非守护线程，守护线程通常由虚拟机自己使用，如执行垃圾收集任务，jsva程序也可以把它创建的任何线程标记为守护线程。
				只要有任何守护线程在在运行，那java程序也在继续运行，虚拟机存活，如果所有非守护线程都终止时，虚拟机将自动退出。java程序入口main线程是非守护线程
				，因此main执行完成后虚拟机将退出。
			</li>
			<li>.class文件由类加载器加载，然后通过执行引擎把字节码编译成本地可执行代码，一般有三种模式，一次性编译，即时编译（用多少编译多少），自适应监控使用频率，高频率的本地代码被缓存
			</li>
			<li>启动类装载器，用户自定义装载器<br>
				<ul>
					<li>
						启动类装载器：是jvm实现的一部分
					</li>
					<li>
						自定义装载器：是java程序的一部分
					</li>
				</ul>
			</li>
			<li>装载，连接，初始化，其中，连接包括验证，准备，解析（可选）
			</li>
			<li>装载把二进制class文件读取到内存中，并解析，创建对应的方法区数据结构，验证则验证格式等，
				准备是对一些值初始化，如静态变量赋默认值0；解析是把所有结构中的标识符转为内存中存在的对象引用。
				初始化则是执行程序员添加的初始化工作，如把静态变量初始化为3
			</li>
		</ul>
	</p>
	<hr>
	<h2>java虚拟机内存结构</h2>
	<p>
		<ul class="list">
			<li>程序计数器：每个线程都有一个计数器，保存当前正在执行的程序的内存地址。当有多个线程交叉执行时，被中断的线程的程序当前执行到哪条内存地址必然要保存下来，以便用于被中断的线程恢复执行时再按照被中断时的指令地址继续执行下去。为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存,这在某种程度上有点类似于“ThreadLocal”，是线程安全的。</li>
			<li>java栈：存储栈桢，如每调用一个方法，都会创建一个桢，存储局部变量，返回值等，每个线程一个桢。由于Java栈是与线程对应起来的，Java栈数据不是线程共有的，所以不需要关心其数据一致性，也不会存在同步锁的问题。</li>
			<li>本地方法栈：和java栈类似，执行native method服务，jdk跨平台主要是这里的内容不同，其它地方的内容都是一样的</li>
			<li>堆：当前虚拟机所有线程共享，程序中创建的对象放在这里。堆是JVM所管理的内存中最大的一块，是被所有Java线程所共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配</li>
			<li>方法区：存储类信息，名称， 方法，字段等，及静态变量，常量，常量池，当前虚拟机所有线程共享，.class文件解析出来的类信息就存储在这里。方法区存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。方法区是被Java线程锁共享的，不像Java堆中其他部分一样会频繁被GC回收，它存储的信息相对比较稳定，在一定条件下会被GC，当方法区要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。方法区也是堆中的一部分，就是我们通常所说的Java堆中的永久区 Permanet Generation</li>
			<li>常量池：常量池本身是方法区中的一个数据结构。常量池中存储了如字符串、final变量值、类名和方法名常量。常量池在编译期间就被确定，并保存在已编译的.class文件中。一般分为两类：字面量和引用量。字面量就是字符串、final变量等。类名和方法名属于引用量。引用量最常见的是在调用方法的时候，根据方法名找到方法的引用，并以此定为到函数体进行函数代码的执行。引用量包含：类和接口的权限定名、字段的名称和描述符，方法的名称和描述符。</li>
			<li>直接内存区：如nio就直接使用此内存进行文件处理，省了以前在堆区和操作系统内存之间数据复制过程，性能更好</li>
			<li>主内存和工作内存：JVM将内存组织为主内存和工作内存两个部分。主内存主要包括本地方法区和堆，每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程私有的栈和对主存部分变量拷贝的寄存器(包括程序计数器PC和cup工作的高速缓存区)。Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。</li>
		</ul>
	</p>
	<hr>
	<h2>垃圾收集器</h2>
	<p>
		<ul class="list">
			<li>引用计数收集器。每个对象都有引用计数。但无法检测出循环</li>
			<li>跟踪收集器，（标记清除法）</li>
			<li>压缩收集器</li>
			<li>复制收集器</li>
			<li>按代收集</li>


			<li>堆中可分为新生代，老年代，永久代（和方法区相似，1.8被移除，放在metaspace）；新生代分为eden, s0, s1</li>
			<li>eden区回收频率高，效率高，可回收70%~90%对象，剩下对象进入s0,每回收一次，s0所有幸存对象放到s1，s0和s1身份互换，再次回收
				s1所有幸存对象放到s0，回收次数过多（一般为年龄15次后进入老年代，大对象一般也放在老年代）
			</li>
			<li>热点探测法，java代码jit即时编译，如果次数达到一定次数则会进行缓存，提高性能</li>
			<li>1.引用计数法，程序会暂停，2.复制法，3.标记清除法，4.标记整理法</li>
		</ul>
	</p>
	<hr>
	<h2>对象是否可回收</h2>
	<p>
		<ul class="list">
			<li>引用记数法</li>
			<li>可达性分析法</li>
		</ul>
	</p>
	<h2>垃圾收集算法</h2>
	<p>
		<ul class="list">
			<li>标记清除法，不足是标记和清除效率都低，且会产生碎片</li>
			<li>复制算法，效率高，但浪费内存</li>
			<li>标记整理算法， 一块空间，和标记清除法一样，清除完成后从头依次排列</li>
			<li>分代收集器</li>
		</ul>
	</p>
	<hr>
	<h2>对象内存</h2>
	<p>
		<ul class="list">
			<li>对象头，实例数据，对齐填充</li>
			<li>对象头存储两部分，一是存储对象自身运行时数据，如哈希码，gc分代年龄，线程持有锁，二是类型指针，指向类元数据的指针</li>
			<li>实例数据部分则是存储对象的有效信息</li>
			<li>对象的访问定位方式有两种，一是使用句柄，即句柄是中间变量，它指向真正的数据值，对象移动时处理简单，但会多一次指针寻址；二是直接指针，性能快，但复制对象时处理地址麻烦</li>
		</ul>
	</p>
	<hr>
	<h2>名词说明</h2>
	<p>
		<ul class='list'>
			<li>Minor GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存
				<ul class='list'>
				  <li>当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。</li>
				  <li>内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。</li>
				  <li>执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。</li>
				  <li>质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。</li>
				</ul>
			</li>
			<li>Major GC 是清理老年代。很不幸，实际上它还有点复杂且令人困惑。首先，许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。另一方面，许多现代垃圾收集机制会清理部分永久代空间，所以使用“cleaning”一词只是部分正确。</li>
			<li>Full GC 是清理整个堆空间—包括年轻代和老年代。触发条件
			    <ul class='list'>
			      <li>调用System.gc</li>
			      <li>老年代堆空间不足</li>
			    </ul>
			</li>
		</ul>
	</p>
</body> 
</html>
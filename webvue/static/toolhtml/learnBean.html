<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'> 
	<title>学习bean</title>
	<link rel='stylesheet' type='text/css' href='../bootstrap/css/bootstrap.min.css'>
	<link rel='stylesheet' type='text/css' href='../css/common.css'>
</head> 
<body class='elearn'>
	<h2>bean初始化，要实现对Bean创建初始化的Hook，有以下几种常用的方式来实现</h2>
	<p>
		<ul class='list'>
			<li>如果要对多种Bean进行Hook，可以使用BeanPostProcessor来实现。</li>
			<li>Bean类实现InitializingBean接口。</li>
			<li>在bean的初始化方法中添加PostConstruct注解。PostConstruct注解的初始化功能也是通过实现了BeanPostProcessor接口的bean来完成的。这个BeanPostProcessor会查找初始化类里面具有PostConstruct方法，然后进行调用。</li>
			<li>bean创建的时候指定init-method</li>
			<li>以上方式执行顺序：构造方法->Before Initialization->使用PostConstruct注解->InitializingBean接口->init-method指定的初始化方法->After Initialization。</li>
		</ul>
	</p>
	<hr>
	<h2>
		spring 提供两种容器实现,BeanFactory和ApplicationContext
	</h2>
	<ul class='list'>
		<li>BeanFactory是spring框架的基础设施，面向spring本身</li>
		<li>ApplicationContext面向开发者，几乎所有场合都用ApplicationContext，而不用BeanFactory，主要有三种实现类
			<ul class='list'>
				<li>
					ClassPathXmlApplicationContext。ApplicationContext ctx = new ClassPathXmlApplicationContext("bean
		xml地址，如applicationContext.xml");<br>
		ctx.getBean("id");
				</li>
				<li>
					FileSystemXmlApplicationContext
				</li>
				<li>
					WebApplicationContext，在web系统中常用
				</li>
			</ul>
		</li>
	</ul>
	<hr>
	<h2>配置bean</h2>
	<ul class='list'>
		<li>xml和注解</li>
		<li>bean是通过反射的方式创建，因此必须要有一个无参的构造函数</li>
		<li>若xml配置中没有指定id,则以类名作为bean的名字，id可以指定多个，以逗号，分号或空格分隔</li>
		<li>在bean的xml配置中可以使用autowire="byName"表示实体属性通过名称自动装配，byType则是根据类型进行自动装配，但同一类型的bean只能有一个</li>
	</ul>
	<hr>
	<h2>bean之间的关系</h2>
	<ul class='list'>
		<li>继承，可以使用parent来继承同类型(或父类?)的bean，若只想设置为模板，则可设置abstract属性为true，
			并不是实例中的所有属性都会继承，如abstract，autowired；若一个bean没有指定类型，则必须为abstract
		</li>
		<li>依赖，使用depends-on属性来创建依赖，属性值为bean的id，依赖多个bean，值用逗号或空格隔开</li>
	</ul>
	<hr>
	<h2>bean作用域， 可以用scope属性指定</h2>
	<ul class='list'>
		<li>单例(singleton)，默认都是单例的，容器初始化时创建bean实例，整个容器生命周期内都只会创建一个实例</li>
		<li>请求(request)，不同的请求之间的bean不同，同一请求之间是共享的bean</li>
		<li>会话(session)，不同的会话之间的bean不同，同一会话之间是共享的bean</li>
		<li>原型(prototype)，容器初始化时不创建bean，每次请求时才会创建新的bean</li>
	</ul>
	<hr>
	<h2>使用外部属性文件</h2>
	<ul class='list'>
		<li>属性值在properties中，在bean中使用${driverClass}来配置</li>
	</ul>

	<hr>
	<h2>spring 依赖注入</h2>
	<ul class='list'>
		<li>构造函数注入, &lt;constructor-arg value=""&gt;&lt;/constructor-arg&gt;,添加多个，按参数顺序来配置，还可以添加index属性指定参数顺序<br>
			还可以添加type属性指定类型，以区别重载构造函数
		</li>
		<li>属性注入， &lt;property name="" value=""&gt;&lt;/property&gt;</li>
		<li>工厂注入，一般不用</li>
	</ul>
	<div>
		<p>创建bean的工厂方法，在bean节点上指定factory-method</p>
	</div>
	<hr>
	<h2>创建bean方式</h2>
	<ul class='list'>
		<li>静态工厂方法。要创建的bean, class指定为工厂类型，通过factory-method属性指定工厂方法，通过constructor-arg子节点指定参数值</li>
		<li>实例工厂方法。在创建的bean上，指定factory-bean为工厂实例bean(即要先配置工厂bean)，factory-method指定工厂方法，constructor-arg子节点传递参数</li>
		<li>通过spring框架的FactoryBean泛型接口的实现类来创建bean</li>
	</ul>
	<hr>
	<h2>注解配置bean，需要在配置文件中配置&lt;context:component-scan&gt;&lt;/context:component-scan&gt;</h2>
	<ul class='list'>
		<li>
			@Component，基本注解，标识一个受spring管理的组件
		</li>
		<li>
			@Respository，持久层组件
		</li>
		<li>
			@Service，服务层（业务层）的组件
		</li>
		<li>
			@Controller，表现层的组件
		</li>
		<li>
			@Resource。是J2EE注解。没有指定则默认通过name属性去匹配bean，找不到再按type去匹配。指定了name或者type则根据指定的类型去匹配bean。若指定了但没有匹配到，则抛异常
		</li>
		<li>
			@Autowired。是spring注解。默认按照byType方式进行bean匹配,和@Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。默认按类型进行装配，可以自动装配类型兼容的属性，表示容器中必须要有兼容的bean实例，否则会报错，如果不想报错可以使用@Autowired(required=false)， 如果属性为数组，会把所有匹配的bean进行装配，如果属性为集合，会把所有兼容bean进行装配，如果为map，键为String，会把类型兼容的bean进行填充， 键为bean的名称
		</li>
		<li>
			@Qualifier。指定beanq名称，和Autowired配合使用
		</li>
		<li>@Named。指定bean名称</li>
		<li>@Inject。是J2EE注解。是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named；
		<ul class='list'>
		  <li>@Autowired是spring自带的，@Inject是JSR330规范实现的，@Resource是JSR250规范实现的，需要导入不同的包</li>
		  <li>@Autowired、@Inject用法基本一样，不同的是@Autowired有一个request属性</li>
		  <li>@Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的</li>
		  <li>@Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用</li>
		</ul>
		</li>
	</ul>
	<hr>
	<h2>context:component-scan属性</h2>
	<ul>
		<li>base-package指定要扫描的包，包括子包</li>
		<li>user-default-filters=false；默认为true, 要设置为不使用默认过滤，context:include-filter和context:exclude-filter才会生效</li>
	</ul>
	<hr>
	<h2>context:component-scan子节点</h2>
	<ul class='list'>
		<li>
			resource-pattern；resuorce-pattern="repositor/*.class"，指定扫描的资源
		</li>
		<li>
			context:include-filter；包含类型,可以设置多个
		</li>
		<li>
			context:exclude-filter；排除类型,可以设置多个
			<ul class='list'>
				<li>type=annotation expression=xxx.xxx.注解名</li>
				<li>assignable；指定class或interface</li>
				<li>aspectj；aspectJ；语法</li>
				<li>regex；正则表达式</li>
				<li>custom</li>
			</ul>
		</li>
	</ul>
</body> 
</html>